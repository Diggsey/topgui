#constant guiId integer

type guiInteractionType
    deltaX as integer
    deltaY as integer
    deltaW as integer
    deltaH as integer
    scrollX as integer
    scrollY as integer
endtype

` All global non-array data related to the gui should be stored in here:
type guiContextType
    hotId as guiId
    activeId as guiId
    nextHotId as guiId
    scrollId as guiId
    stayActive as boolean
    msc as integer  ` Mouse click
    msx as integer  ` Mouse X
    msy as integer  ` Mouse Y
    omc as integer  ` Old mouse click
    omx as integer  ` Old mouse X
    omy as integer  ` Old mouse Y
    mmz as integer  ` Mouse wheel
    msd as integer  ` Mouse down
    msu as integer  ` Mouse up
    fontId as integer
    defaultFontId as integer
    rootFocused as boolean
    modalId as guiId
    
    ` Active data
    dragMode as integer
    dragX as integer
    dragY as integer
    delayTime as integer
    currentOverlay as integer
    overlayHotId as integer
    counter as integer
    
    ` Moving/resizing
    interaction as guiInteractionType
    
    ` Focus data
    focusId as guiId
    oldFocusId as guiId
    veryOldFocusId as guiId
    newFocusId as guiId
    prevFocusId as guiId
    nextFocusId as guiId
    overrideFocusId as guiId
    selStart as integer
    selEnd as integer
    overrideSelStart as integer
    overrideSelEnd as integer
    tempBuffer as string
    entryBuffer as string
    cursorTimer as integer
    tempScroll as integer
    tempText as string
    
    ` Layout
    layoutX as integer
    layoutY as integer
    layoutW as integer
    layoutH as integer
endtype

type guiRectType
    x1 as integer
    y1 as integer
    x2 as integer
    y2 as integer
    offsetx as integer
    offsety as integer
endtype

type guiDrawTargetType
    targetId as integer
    targetType as integer `0 = Bitmap, 1 = Camera, 2 = Image
endtype

type guiOverlayType
    ownerId as guiId
    imageId as integer
    used as boolean
    x as integer
    y as integer
    color as integer
    animationType as integer
    animationStart as integer
    animationLength as integer
    shadowRadius as integer
endtype

type guiCachedTextType
    fontId as integer
    textStr as string
    imageId as integer
    halign as integer
    valign as integer
    width as integer
    height as integer
    wordWrap as boolean
    used as boolean
endtype

type guiModalType
    id as guiId
    parentId as guiId
    functionPtr as integer
    param as integer
    focused as boolean
    x as integer
    y as integer
    width as integer
    height as integer
    closed as boolean
endtype

global guiModal as guiModalType
global gui as guiContextType

` Initialize gui
function guiInit()
    ` Insert ASM code into getReturnAddress:
    `   0x8B 0x45 0x04      mov eax, [ebp+4]
    `   0xC3                ret
    ` (Bytes reversed to get correct endian-ness:)
    poke dword get ptr to function("getReturnAddress"), 0xC304458B
    
    ` Insert ASM code into getReturnEBP:
    `   0x8B 0x45 0x00      mov eax, [ebp+0]
    `   0xC3                ret
    ` (Bytes reversed to get correct endian-ness:)
    poke dword get ptr to function("getReturnEBP"), 0xC300458B

    global dim guiClip() as guiRectType
    global dim guiIdStack() as guiId
    global dim guiHotParentIds() as guiId
    global dim guiFocusParentIds() as guiId
    global dim guiInteractions() as guiInteractionType
    global dim guiDataStackInteger() as integer
    global dim guiDataStackString() as string
    global dim guiDrawTargetStack() as guiDrawTargetType
    global dim guiOverlays() as guiOverlayType
    global dim guiCachedText() as guiCachedTextType
    global dim guiMenuStack() as guiId
    global dim guiModalStack() as guiModalType
    global dim guiLayoutStack() as integer
    
    set array index guiClip(), -1
    set array index guiIdStack(), -1
    set array index guiHotParentIds(), -1
    set array index guiFocusParentIds(), -1
    set array index guiInteractions(), -1
    set array index guiDataStackInteger(), -1
    set array index guiDataStackString(), -1
    set array index guiDrawTargetStack(), -1
    set array index guiOverlays(), -1
    set array index guiCachedText(), -1
    set array index guiMenuStack(), -1
    set array index guiModalStack(), -1
    set array index guiLayoutStack(), -1
    
    ` Alpha blend RGB channels, add alpha channels
    a2SetBlendMode 5, 6, 1, 2, 2, 1
    
    gui.defaultFontId = a2CreateFont("Tahoma", 12, a2Size_Point(), a2Style_Bold())
    gui.fontId = gui.defaultFontId
    gui.currentOverlay = -1
    
    set message callback "guiWndProc"
    
    guiPushLayout(0)
    guiSetTheme("Default")
endfunction

#constant guiWM_CHAR 0x102
#constant guiWM_KEYDOWN 0x100
#constant guiWM_KEYUP 0x101

function guiWndProc(hwnd as dword, msg as dword, wparam as dword, lparam as dword)
    select msg
        case guiWM_CHAR
            repeatCount = lparam and 0xFFFF
            for i = 1 to repeatCount
                gui.tempBuffer = gui.tempBuffer + chr$(1) + chr$(wparam and 0xFF)
            next i
        endcase
        case guiWM_KEYDOWN
            repeatCount = lparam and 0xFFFF
            for i = 1 to repeatCount
                firstTime = (lparam and 0x40000000) <> 0 and i = 1
                if firstTime
                    gui.tempBuffer = gui.tempBuffer + chr$(2) + chr$(wparam and 0xFF)
                else
                    gui.tempBuffer = gui.tempBuffer + chr$(3) + chr$(wparam and 0xFF)
                endif
            next i
        endcase
        case guiWM_KEYUP
            repeatCount = lparam and 0xFFFF
            for i = 1 to repeatCount
                gui.tempBuffer = gui.tempBuffer + chr$(4) + chr$(wparam and 0xFF)
            next i
        endcase
    endselect
endfunction result

function guiProcessKeyDown(id as guiId, keyCode, firstTime)
    if id <> guiGetFocus()
        exitfunction 0
    endif

    l = fast len(gui.entryBuffer)-1
    for i = 1 to l step 2
        mode = mid ascii(gui.entryBuffer, i)
        if (mode = 2) or ((mode = 3) and (firstTime = 0))
            key = mid ascii(gui.entryBuffer, i+1)
            if key = keyCode
                gui.entryBuffer = remove$(gui.entryBuffer, i, 2)
                
                exitfunction 1
            endif
        endif
    next i
endfunction 0

function guiProcessKeyUp(id as guiId, keyCode)
    if id <> guiGetFocus()
        exitfunction 0
    endif

    l = fast len(gui.entryBuffer)-1
    for i = 1 to l step 2
        mode = mid ascii(gui.entryBuffer, i)
        if mode = 4
            key = mid ascii(gui.entryBuffer, i+1)
            if key = keyCode
                gui.entryBuffer = remove$(gui.entryBuffer, i, 2)
                
                exitfunction 1
            endif
        endif
    next i
endfunction 0

` Will be replaced by ASM code at init time
function getReturnAddress()
endfunction result

` Will be replaced by ASM code at init time
function getReturnEBP()
endfunction result

` DO NOT USE!
function setParam(addr, ebp, index, value)
    ptr = ebp + peek integer(addr - index*7 - 10)
    poke integer ptr, value
endfunction

` GEN_ID - Generate a unique but consistent control ID
` INDEX_ID(x) - Generate a control ID based on an index
` CHILD_ID(x) - Generate a control ID based on a parent ID
` CHILD_INDEX_ID(x) - Generate a control ID based on a parent ID and an index
` RND_ID - Generate a random and inconsistent control ID
#constant GEN_ID INDEX_ID(0)
#constant RND_ID ((rnd(0xFFFF) << 16) || rnd(0xFFFF))
function INDEX_ID(index)
    result = -(getReturnAddress() << 10) + index
endfunction result
function CHILD_ID(parentId as guiId)
    result = -(getReturnAddress() << 10) + (parentId << 12)
endfunction result
function CHILD_INDEX_ID(parentId as guiId, index)
    result = -(getReturnAddress() << 10) + (parentId << 12) + index
endfunction result

function guiLayout(id as guiId, x, y, w, h)
    ptr = guiPeekLayout(0)
    if ptr
        call function ptr ptr, id, x, y, w, h
        
        addr = getReturnAddress()
        ebp = getReturnEBP()
        setParam(addr, ebp, 1, gui.layoutX)
        setParam(addr, ebp, 2, gui.layoutY)
        setParam(addr, ebp, 3, gui.layoutW)
        setParam(addr, ebp, 4, gui.layoutH)
    endif
endfunction

function guiPushLayout(v)
    `add to stack guiLayoutStack()
    next array index guiLayoutStack()
    if array index valid(guiLayoutStack()) = 0 then array insert at bottom guiLayoutStack()
    guiLayoutStack() = v
endfunction

function guiPushLayoutName(name$)
    guiPushLayout(get ptr to function(name$))
endfunction

function guiPopLayout()
    v = guiLayoutStack()
    `remove from stack guiLayoutStack()
    previous array index guiLayoutStack()
endfunction v

function guiPeekLayout(offset)
    v = guiLayoutStack(get array index(guiLayoutStack())-offset)
endfunction v

function guiPokeLayout(offset, v)
    guiLayoutStack(get array index(guiLayoutStack())-offset) = v
endfunction

function guiModalContainer(id as guiId, focused)
    n = get array index(guiModalStack())
    for i = n to 0 step -1
        if guiModalStack(i).parentId = id
            guiModalStack(i).focused = focused
            focused = 0
            
            if gui.modalId = 0 then gui.modalId = guiModalStack(i).id
        endif
    next i
endfunction focused

function guiUpdateModalChildren(id as guiId)
    modalCopy as guiModalType
    modalCopy = guiModal

    for i = 0 to get array index(guiModalStack())
        if guiModalStack().parentId = id
            guiModal = guiModalStack(i)
            
            if gui.modalId = guiModal.id then gui.modalId = 0
            
            guiSetHotParents(guiModal.id)
            
            if guiModal.closed
                guiModal.closed = 0
                opened = 1
            else
                opened = 0
            endif
            
            call function ptr guiModal.functionPtr, opened
            
            if guiModal.closed = 0
                guiModalStack(i) = guiModal
            else
                array delete element guiModalStack(), i
                array index to stack guiModalStack()
                dec i
            endif
        endif
    next i
    
    guiModal = modalCopy
endfunction

function guiUpdate()
    guiUpdateModalChildren(0)

    ` Close submenus when parent is clicked
    if gui.msd = 1
        guiMenuCloseChildren(guiGetHot())
    endif

    ` Update overlays
    n = array count(guiOverlays())
    for i = 0 to n
        if guiOverlays(i).used
            overlay as guiOverlayType
            overlay = guiOverlays(i)
            
            width = image width(overlay.imageId)
            height = image height(overlay.imageId)
            
            guiOverlays(i).used = 0
            
            x1 = overlay.x
            y1 = overlay.y
            
            deltaTime = min(timer()-overlay.animationStart, overlay.animationLength)
            
            ` Fade in
            if overlay.animationType and 1
                alpha = rgba(overlay.color)
                alpha = (deltaTime*alpha)/overlay.animationLength
                color = set alpha(overlay.color, alpha)
            else
                color = overlay.color
            endif
            
            ` Expand X
            if overlay.animationType and 2
                x2 = x1+(deltaTime*width)/overlay.animationLength
            else
                x2 = x1+width
            endif
            
            ` Expand Y
            if overlay.animationType and 4
                y2 = y1+(deltaTime*height)/overlay.animationLength
            else
                y2 = y1+height
            endif
            
            if overlay.shadowRadius
                guiDrawShadow(x1, y1, x2, y2, overlay.shadowRadius)
            endif
            
            guiPushClip(x1, y1, x2, y2, 0, 0, 1)
            a2DrawImage overlay.imageId, overlay.x, overlay.y, 0, 0, 0, 1, 0, color
            guiPopClip()
            
            if guiInRect(gui.msx, gui.msy, overlay.x, overlay.y, overlay.x+width, overlay.y+height)
                guiSetHot(overlay.ownerId)
            endif
        else
            delete image guiOverlays(i).imageId
            array delete element guiOverlays(), i
            dec i
            dec n
        endif
    next i
    
    ` A control must keep itself active to stay active
    if gui.stayActive = 0
        gui.activeId = 0
        gui.delayTime = 0
    else
        gui.stayActive = 0
    endif
    
    gui.veryOldFocusId = gui.oldFocusId
    gui.oldFocusId = gui.focusId
    if gui.overrideFocusId <> -1
        gui.focusId = gui.overrideFocusId
        gui.selStart = gui.overrideSelStart
        gui.selEnd = gui.overrideSelEnd
        gui.tempScroll = 0
        gui.overrideFocusId = -1
    else
        gui.focusId = gui.newFocusId
        
        if gui.focusId <> gui.oldFocusId
            gui.tempScroll = 0
            gui.selStart = -1
            gui.selEnd = -1
        endif
    endif
    gui.newFocusId = 0
    
    nextHotId as guiId
    if gui.overlayHotId
        nextHotId = gui.overlayHotId
    else
        nextHotId = gui.nextHotId
    endif
    if gui.activeId
        ` Only active control can become hot
        if gui.activeId = nextHotId
            gui.hotId = nextHotId
        else
            gui.hotId = 0
        endif
    else
        gui.hotId = nextHotId
    endif
    gui.nextHotId = 0
    gui.overlayHotId = 0
    
    ` Get mouse input
    gui.omc = gui.msc
    gui.omx = gui.msx
    gui.omy = gui.msy
    gui.msc = mouseclick()
    gui.msx = mousex()
    gui.msy = mousey()
    gui.mmz = mousemovez()/-120
    ` Mouse down = clicked now and not clicked before
    gui.msd = gui.msc and (not gui.omc)
    ` Mouse up = clicked before and not clicked now
    gui.msu = gui.omc and (not gui.msc)
    
    ` Clear unused text from the cache
    n = array count(guiCachedText())
    for i = 0 to n
        if guiCachedText(i).used = 0
            delete image guiCachedText(i).imageId
            array delete element guiCachedText(), i
            dec i
            dec n
        else
            guiCachedText(i).used = 0
        endif
    next i
    
    ` Fetch new events
    gui.entryBuffer = gui.tempBuffer
    gui.tempBuffer = ""
    
    gui.rootFocused = guiModalContainer(0, 1)
endfunction

function guiRootFocused()
    focused = gui.rootFocused
endfunction focused

function guiMouseX()
    x = gui.msx - guiOverlayX()
endfunction x

function guiMouseY()
    y = gui.msy - guiOverlayY()
endfunction y

function guiMoveX(x, minX, maxX, w, minW, maxW)
    oldx = x
    oldw = w
    x = clamp(x + gui.interaction.deltaX, minX, maxX)
    w = clamp(w + gui.interaction.deltaW, minW, maxW)
    
    if gui.interaction.deltaW <> 0 and gui.interaction.deltaX <> 0
        x = oldx+oldw-w
        if x < minX
            x = minX
            w = oldx+oldw-x
        endif
    endif
    
    gui.interaction.deltaW = w-oldw
    gui.interaction.deltaX = 0
endfunction x

function guiMoveY(y, minY, maxY, h, minH, maxH)
    oldy = y
    oldh = h
    y = clamp(y + gui.interaction.deltaY, minY, maxY)
    h = clamp(h + gui.interaction.deltaH, minH, maxH)
    
    if gui.interaction.deltaH <> 0 and gui.interaction.deltaY <> 0
        y = oldy+oldh-h
        if y < minY
            y = minY
            h = oldy+oldh-y
        endif
    endif
    
    gui.interaction.deltaH = h-oldh
    gui.interaction.deltaY = 0
endfunction y

function guiResizeW(w)
    inc w, gui.interaction.deltaW
    gui.interaction.deltaW = 0
endfunction w

function guiResizeH(h)
    inc h, gui.interaction.deltaH
    gui.interaction.deltaH = 0
endfunction h

function guiScrollX()
endfunction gui.interaction.scrollX

function guiScrollY()
endfunction gui.interaction.scrollY

function guiPushClip(x1, y1, x2, y2, scrollx, scrolly, child)

    if child and (get array index(guiClip()) >= 0)
        ox = guiClip().offsetx
        oy = guiClip().offsety
        offsetx = x1 + ox - scrollx
        offsety = y1 + oy - scrolly
        
        ` Intersect clip regions
        x1 = max(x1 + ox, guiClip().x1)
        y1 = max(y1 + oy, guiClip().y1)
        x2 = min(x2 + ox, guiClip().x2)
        y2 = min(y2 + oy, guiClip().y2)
    else
        offsetx = x1 - scrollx
        offsety = y1 - scrolly
    endif

    `add to stack guiClip()
    next array index guiClip()
    if array index valid(guiClip()) = 0 then array insert at bottom guiClip()
    guiClip().x1 = x1
    guiClip().y1 = y1
    guiClip().x2 = x2
    guiClip().y2 = y2
    guiClip().offsetx = offsetx
    guiClip().offsety = offsety
    
    x1 = clamp(x1, 0, draw target width())
    y1 = clamp(y1, 0, draw target height())
    x2 = clamp(x2, x1, draw target width())
    y2 = clamp(y2, y1, draw target height())
    
    if x1 = x2 or y1 = y2
        x1 = -1
        y1 = -1
        x2 = -1
        y2 = -1
    endif
        
    a2SetClip x1, y1, x2, y2

endfunction

function guiPopClip()
    `remove from stack guiClip()
    previous array index guiClip()
    
    if get array index(guiClip()) >= 0
        x1 = guiClip().x1
        y1 = guiClip().y1
        x2 = guiClip().x2
        y2 = guiClip().y2
        
        x1 = clamp(x1, 0, draw target width())
        y1 = clamp(y1, 0, draw target height())
        x2 = clamp(x2, x1, draw target width())
        y2 = clamp(y2, y1, draw target height())
        
        if x1 = x2 or y1 = y2
            x1 = -1
            y1 = -1
            x2 = -1
            y2 = -1
        endif
        
        a2SetClip x1, y1, x2, y2
    else
        a2SetClip 0, 0, draw target width(), draw target height()
    endif
endfunction

function guiAdjustX(x)
    if get array index(guiClip()) >= 0
        inc x, guiClip().offsetx
    endif
endfunction x

function guiAdjustY(y)
    if get array index(guiClip()) >= 0
        inc y, guiClip().offsety
    endif
endfunction y

function guiOverlayX()
    if gui.currentOverlay <> -1
        x = guiOverlays(gui.currentOverlay).x
    else
        x = 0
    endif
endfunction x

function guiOverlayY()
    if gui.currentOverlay <> -1
        y = guiOverlays(gui.currentOverlay).y
    else
        y = 0
    endif
endfunction y

function guiBeginControl(x, y, w, h, child)
    guiPushClip(x, y, x+w, y+h, 0, 0, child)
endfunction

function guiEndControl()
    guiPopClip()
endfunction

function guiSetHotParents(id as guiId)
    if gui.hotId = id
        N = get array index(guiIdStack())
        
        global dim guiHotParentIds(N) as guiId
        for i = 0 to N
            guiHotParentIds(i) = guiIdStack(i)
        next i
    endif
endfunction

function guiSetHot(id as guiId)
    if gui.currentOverlay <> -1
        gui.overlayHotId = id
    else
        if gui.modalId
            gui.nextHotId = gui.modalId
        else
            gui.nextHotId = id
        endif
    endif
    
    guiSetHotParents(id)
endfunction

function guiIsChildHot(id as guiId)
    N = array count(guiHotParentIds())
    for i = 0 to N
        if id = guiHotParentIds(i)
            exitfunction 1
        endif
    next i
endfunction 0

function guiIsChildFocused(id as guiId)
    N = array count(guiFocusParentIds())
    for i = 0 to N
        if id = guiFocusParentIds(i)
            exitfunction 1
        endif
    next i
endfunction 0

function guiGetHot()
endfunction gui.hotId

function guiSetActive(id as guiId)
    if id
        if gui.activeId = 0 or gui.activeId = id
            gui.activeId = id
            gui.stayActive = 1
        else
            exitfunction 0
        endif
    else
        gui.activeId = 0
        gui.stayActive = 0
    endif
endfunction 1

function guiStayActive()
    gui.stayActive = 1
endfunction

function guiGetActive()
endfunction gui.activeId

function guiInRect(x, y, x1, y1, x2, y2)
    if x >= x1 and x < x2
        if y >= y1 and y < y2
            exitfunction 1
        endif
    endif
endfunction 0

function guiInClip(x, y)
    if get array index(guiClip()) >= 0
        result = guiInRect(x, y, guiClip().x1, guiClip().y1, guiClip().x2, guiClip().y2)
    else
        result = 1
    endif
endfunction result

function guiInEllipse(x, y, x1, y1, x2, y2)
    rx = (x2-x1)/2
    ry = (y2-y1)/2
    rx2 = rx*rx
    ry2 = ry*ry
    
    dx = x-(x1+x2)/2
    dy = y-(y1+y2)/2
    
    result = (dx*dx)*ry2 + (dy*dy)*rx2 <= rx2*ry2
endfunction result

function guiSetFont(fontId)
    if fontId
        gui.fontId = fontId
    else
        gui.fontId = gui.defaultFontId
    endif
endfunction

function guiPushInteraction()
    `add to stack guiInteractions()
    next array index guiInteractions()
    if array index valid(guiInteractions()) = 0 then array insert at bottom guiInteractions()
    guiInteractions() = gui.interaction
endfunction

function guiClearInteraction()
    gui.interaction.deltaX = 0
    gui.interaction.deltaY = 0
    gui.interaction.deltaW = 0
    gui.interaction.deltaH = 0
    gui.interaction.scrollX = 0
    gui.interaction.scrollY = 0
endfunction

function guiPopInteraction()
    gui.interaction = guiInteractions()
    `remove from stack guiInteractions()
    previous array index guiInteractions()
endfunction

function guiGetOverlay(id as guiId, w, h)
    n = array count(guiOverlays())
    overlayIndex = -1
    for i = 0 to n
        if guiOverlays(i).ownerId = id
            imageId = guiOverlays(i).imageId
            if (image width(imageId) >= w) and (image height(imageId) >= h)
                overlayIndex = i
                exit
            endif
        endif
    next i
    
    if overlayIndex = -1
        array insert at bottom guiOverlays()
        overlayIndex = n+1
        
        imageId = reserve free image()
        make image imageId, w, h, 21
        
        guiOverlays(overlayIndex).ownerId = id
        guiOverlays(overlayIndex).imageId = imageId
        guiOverlays(overlayIndex).animationStart = 0
    endif
    
    guiOverlays(overlayIndex).used = 1
endfunction overlayIndex

function guiBeginOverlay(id as guiId, x, y, w, h, color, animationType, animationLength, shadowRadius)
    if guiInRect(gui.msx, gui.msy, x, y, x+w, y+h)
        gui.overlayHotId = id
    endif

    overlayIndex = guiGetOverlay(id, w, h)
    guiOverlays(overlayIndex).x = x
    guiOverlays(overlayIndex).y = y
    guiOverlays(overlayIndex).color = color
    guiOverlays(overlayIndex).animationType = animationType
    guiOverlays(overlayIndex).animationLength = animationLength
    guiOverlays(overlayIndex).shadowRadius = shadowRadius
    if guiOverlays(overlayIndex).animationStart = 0
        guiOverlays(overlayIndex).animationStart = timer()
    endif
    
    guiPushInteger(draw target type())
    guiPushInteger(draw target())
    guiPushInteger(gui.currentOverlay)
    
    draw to image guiOverlays(overlayIndex).imageId
    
    guiPushClip(0, 0, w, h, 0, 0, 0)
    
    cls 0
    
    gui.currentOverlay = overlayIndex
endfunction

function guiEndOverlay()
    gui.currentOverlay = guiPopInteger()
    drawTarget = guiPopInteger()
    drawTargetType = guiPopInteger()
    
    set draw target drawTargetType, drawTarget

    guiPopClip()
endfunction

function guiBeginContainer(id as guiId, x, y, w, h, scrollx, scrolly)
    guiPushClip(x, y, x+w, y+h, scrollx, scrolly, 1)
    guiPushInteraction()
    
    `add to stack guiIdStack()
    next array index guiIdStack()
    if array index valid(guiIdStack()) = 0 then array insert at bottom guiIdStack()
    guiIdStack() = id
    
    guiPushLayout(0)
endfunction

function guiEndContainer()
    guiPopLayout()
    
    guiUpdateModalChildren(guiIdStack())

    `remove from stack guiIdStack()
    previous array index guiIdStack()

    guiPopInteraction()
    guiPopClip()
endfunction

function guiSetDelay(id as guiId, delay as integer)
    if gui.activeId = id
        gui.delayTime = timer() + delay
    endif
endfunction

function guiClearDelay(id as guiId)
    if gui.activeId = id
        gui.delayTime = 0
    endif
endfunction

function guiHasDelayed()
    if gui.delayTime <> 0 and timer() >= gui.delayTime
        exitfunction 1
    endif
endfunction 0

function guiFocus(id as guiId, tabFocus)
    if gui.modalId = 0
        if gui.newFocusId = 0 then gui.newFocusId = id
        if gui.overrideFocusId = 0 then gui.overrideFocusId = id
    endif

    if gui.focusId = id
        gui.newFocusId = id
        
        if guiProcessKeyDown(id, VK_TAB, 0) and tabFocus
            if shiftkey()
                gui.newFocusId = gui.prevFocusId
            else
                gui.newFocusId = gui.nextFocusId
            endif
        endif
        
        gui.nextFocusId = 0
    else
        if gui.modalId = 0
            gui.prevFocusId = id
            if gui.nextFocusId = 0 then gui.nextFocusId = id
        endif
    endif

    result = (gui.focusId = id)
    
    if result
        N = get array index(guiIdStack())
        
        global dim guiFocusParentIds(N) as guiId
        for i = 0 to N
            guiFocusParentIds(i) = guiIdStack(i)
        next i
    endif
endfunction result

function guiGetFocus()
endfunction gui.focusId

function guiSetFocus(id as guiId, initialSelStart, initialSelEnd)
    gui.overrideFocusId = id
    gui.newFocusId = 0
    gui.overrideSelStart = initialSelStart
    gui.overrideSelEnd = initialSelEnd
    
    if gui.focusId = id
        gui.selStart = initialSelStart
        gui.selEnd = initialSelEnd
    endif
endfunction

function guiGame(id as guiId, x, y, w, h)
    guiLayout(id, x, y, w, h)

    guiBeginControl(x, y, w, h, 1)
    
    focused = guiFocus(id, 1)
    
    if guiInClip(guiMouseX(), guiMouseY())
        guiSetHot(id)
    endif
    
    ` If we're the active control
    if guiGetActive() = id
        guiStayActive()
        
        ` If left button was released
        if gui.msu = 1
            ` No longer active
            guiSetActive(0)
        endif
        
        ` If other button was pressed
        if gui.msd
            ` No longer active
            guiSetActive(0)
        endif
    else
        ` If we're the hot control
        if guiGetHot() = id
            ` If left button was pressed
            if gui.msd = 1
                ` Make us active
                guiSetActive(id)
                guiSetFocus(id, 0, 0)
            endif
        endif
    endif
    
    guiGetScroll(id, id)
    
    guiEndControl()
endfunction focused

function guiDrawFocusRect(x1, y1, x2, y2, color)
    batchSize = (x2 - x1) + (y2 - y1) + 2
    a2StartDotBatch batchSize
    
    toggle = 1
    for x = x1 to x2-1
        if toggle
            a2Dot x, y1, color
        endif
        toggle = 1-toggle
    next x
    for y = y1 to y2-1
        if toggle
            a2Dot x2, y, color
        endif
        toggle = 1-toggle
    next y
    for x = x2 to x1+1 step -1
        if toggle
            a2Dot x, y2, color
        endif
        toggle = 1-toggle
    next x
    for y = y2 to y1+1 step -1
        if toggle
            a2Dot x1, y, color
        endif
        toggle = 1-toggle
    next y
    
    a2EndBatch
endfunction

#constant CURSOR_FLASH 600

function guiGetCursorVisible()
    result = ((timer() - gui.cursorTimer) mod (CURSOR_FLASH*2)) < CURSOR_FLASH
endfunction result

function guiSetCursorVisible(visible)
    if visible
        gui.cursorTimer = timer()
    else
        gui.cursorTimer = timer() - CURSOR_FLASH
    endif
endfunction

function guiFocusChanged()
    result = gui.veryOldFocusId <> gui.oldFocusId
endfunction result

function guiGetScroll(id as guiId, redirectId as guiId)
    if gui.msd = 1
        if guiGetHot() = id or guiIsChildHot(id)
            gui.scrollId = redirectId
        endif
    endif
    if gui.scrollId = id
        scroll = gui.mmz
    else
        scroll = 0
    endif
endfunction scroll

function guiPushInteger(value)
    `add to stack guiDataStackInteger()
    next array index guiDataStackInteger()
    if array index valid(guiDataStackInteger()) = 0 then array insert at bottom guiDataStackInteger()
    guiDataStackInteger() = value
endfunction

function guiPopInteger()
    value = guiDataStackInteger()
    `remove from stack guiDataStackInteger()
    previous array index guiDataStackInteger()
endfunction value

function guiPeekInteger()
    value = guiDataStackInteger()
endfunction value

function guiPushString(value$)
    `add to stack guiDataStackInteger()
    next array index guiDataStackString()
    if array index valid(guiDataStackString()) = 0 then array insert at bottom guiDataStackString()
    guiDataStackString() = value$
endfunction

function guiPopString()
    value$ = guiDataStackString()
    `remove from stack guiDataStackInteger()
    previous array index guiDataStackString()
endfunction value$

function guiPeekString()
    value$ = guiDataStackString()
endfunction value$

function guiFastText(fontId, x, y, text$, color)
    n = array count(guiCachedText())
    for i = 0 to n
        if guiCachedText(i).textStr = text$
            if guiCachedText(i).fontId = fontId
                if guiCachedText(i).halign = -1
                    exit
                endif
            endif
        endif
    next i
    
    if i > n
        array insert at bottom guiCachedText()
        guiCachedText(i).fontId = fontId
        guiCachedText(i).textStr = text$
        guiCachedText(i).width = a2GetTextWidth(fontId, text$)
        guiCachedText(i).height = a2GetLineHeight(fontId)
        guiCachedText(i).imageId = reserve free image()
        guiCachedText(i).halign = -1
        guiCachedText(i).valign = -1
        guiCachedText(i).used = 1
        make image guiCachedText(i).imageId, guiCachedText(i).width, guiCachedText(i).height, 21
        
        drawTargetType = draw target type()
        drawTargetId = draw target()
        
        draw to image guiCachedText(i).imageId
        guiPushClip(0, 0, guiCachedText(i).width, guiCachedText(i).height, 0, 0, 0)
        
        cls 0
        a2SetBlendMode 11, 7, 1, 2, 2, 5
        a2Text fontId, 0, 0, text$, 0xFFFFFFFF
        a2SetBlendMode 5, 6, 1, 2, 2, 1
        
        set draw target drawTargetType, drawTargetId
        guiPopClip()
    endif
    
    a2DrawImage guiCachedText(i).imageId, x, y, 0, 0, 0, 1, 0, color
    guiCachedText(i).used = 1
    
endfunction

function guiFastBoxText(fontId, x1, y1, x2, y2, text$, halign, valign, wordWrap, color)
    n = array count(guiCachedText())
    for i = 0 to n
        if guiCachedText(i).textStr = text$
            if guiCachedText(i).width = x2-x1 and guiCachedText(i).height = y2-y1
                if guiCachedText(i).fontId = fontId and guiCachedText(i).wordWrap = wordWrap
                    if guiCachedText(i).halign = halign and guiCachedText(i).valign = valign
                        exit
                    endif
                endif
            endif
        endif
    next i
    
    if i > n
        array insert at bottom guiCachedText()
        guiCachedText(i).fontId = fontId
        guiCachedText(i).textStr = text$
        guiCachedText(i).width = x2-x1
        guiCachedText(i).height = y2-y1
        guiCachedText(i).imageId = reserve free image()
        guiCachedText(i).halign = halign
        guiCachedText(i).valign = valign
        guiCachedText(i).wordWrap = wordWrap
        guiCachedText(i).used = 1
        make image guiCachedText(i).imageId, guiCachedText(i).width, guiCachedText(i).height, 21
        
        drawTargetType = draw target type()
        drawTargetId = draw target()
        
        draw to image guiCachedText(i).imageId
        guiPushClip(0, 0, guiCachedText(i).width, guiCachedText(i).height, 0, 0, 0)
        
        cls 0
        a2SetBlendMode 11, 7, 1, 2, 2, 5
        a2BoxText guiCachedText(i).fontId, 0, 0, x2-x1, y2-y1, guiCachedText(i).textStr, halign, valign, wordWrap, 0xFFFFFFFF
        a2SetBlendMode 5, 6, 1, 2, 2, 1
        
        set draw target drawTargetType, drawTargetId
        guiPopClip()
    endif
    
    guiCachedText(i).used = 1

    a2DrawImage guiCachedText(i).imageId, x1, y1, 0, 0, 0, 1, 0, color
    
endfunction

function guiMenuStackIndex(id as guiId)
    n = get array index(guiMenuStack())
    for i = 0 to n
        if guiMenuStack(i) = id then exitfunction i
    next i
endfunction -1

function guiMenuOpen(id as guiId, parentId as guiId)
    parentIndex = guiMenuStackIndex(parentId)
    set array index guiMenuStack(), parentIndex
    
    guiPushMenu(id)
endfunction

function guiMenuClose(id as guiId)
    index = guiMenuStackIndex(id)
    if index <> -1 then dec index
    set array index guiMenuStack(), index
endfunction

function guiMenuCloseChildren(parentId as guiId)
    index = guiMenuStackIndex(parentId)
    set array index guiMenuStack(), index
endfunction

function guiOpenModalName(id as guiId, parentId as guiId, functionName$, param)
    guiOpenModal(id, parentId, get ptr to function(functionName$), param)
endfunction

function guiOpenModal(id as guiId, parentId as guiId, functionPtr, param)
    add to stack guiModalStack()
    guiModalStack().id = id
    guiModalStack().parentId = parentId
    guiModalStack().functionPtr = functionPtr
    guiModalStack().param = param
    guiModalStack().closed = 1
endfunction

function guiCloseModal()
    guiModal.closed = 1
endfunction

function guiPushMenu(id as guiId)
    `add to stack guiMenuStack()
    next array index guiMenuStack()
    if array index valid(guiMenuStack()) = 0 then array insert at bottom guiMenuStack()
    guiMenuStack() = id
endfunction

function guiPopMenu()
    id as guiId
    id = guiMenuStack()
    `remove from stack guiMenuStack()
    previous array index guiMenuStack()
endfunction id

function guiDrawSector(x, y, radius#, startAngle#, endAngle#, color1, color2)
    a2StartTriangleBatch 60
    for i = 0 to 60
        angle# = i*(endAngle#-startAngle#)/60.0+startAngle#
        x1# = x2#
        y1# = y2#
        x2# = x+sin(angle#)*radius#
        y2# = y-cos(angle#)*radius#
        
        if i
            a2FillTriangle x, y, x1#, y1#, x2#, y2#, color1, color2, color2
        endif
    next i
    a2EndBatch
endfunction

function guiDrawShadow(x1, y1, x2, y2, offset)
    guiDrawSector(x1+offset, y2, offset, 180, 270, THEME_SHADOW_START, THEME_SHADOW_END)
    guiDrawSector(x2, y2, offset, 90, 180, THEME_SHADOW_START, THEME_SHADOW_END)
    guiDrawSector(x2, y1+offset, offset, 0, 90, THEME_SHADOW_START, THEME_SHADOW_END)
    
    a2FillBox x1+offset, y2, x2, y2+offset, THEME_SHADOW_START, THEME_SHADOW_START, THEME_SHADOW_END, THEME_SHADOW_END
    a2FillBox x2, y1+offset, x2+offset, y2, THEME_SHADOW_START, THEME_SHADOW_END, THEME_SHADOW_END, THEME_SHADOW_START
endfunction

function guiDrawTick(x, y)
    a2FillTriangle x+2, y+10, x+8, y+13, x+8, y+17, THEME_TICK_COLOR
    a2FillTriangle x+8, y+17, x+8, y+13, x+16, y+3, THEME_TICK_COLOR
    a2Triangle x+2, y+10, x+8, y+13, x+8, y+17, THEME_TICK_COLOR
    a2Triangle x+8, y+17, x+8, y+13, x+16, y+3, THEME_TICK_COLOR
endfunction

function guiFadeColor(color, alpha)
    color = set alpha(color, (rgba(color)*alpha)/255)
endfunction color

function guiGetTextWidth(text$)
    if text$ = ""
        result = 0
    else
        result = a2GetTextWidth(gui.fontId, text$)
    endif
endfunction result

function guiGetTextWidth2(fontId, text$)
    if text$ = ""
        result = 0
    else
        result = a2GetTextWidth(fontId, text$)
    endif
endfunction result

function guiGetCursorPos(text$, pos, round)
    pos = guiGetCursorPos2(gui.fontId, text$, pos, round)
endfunction pos

function guiGetCursorPos2(fontId, text$, pos, round)
    minChar = 1
    maxChar = fast len(text$)
    
    while maxChar > minChar
        midChar = (minChar+maxChar)/2
        width = guiGetTextWidth2(fontId, fast left$(text$, midChar))
        if width <= pos
            minChar = midChar+1
        else
            maxChar = midChar
        endif
    endwhile
    
    if round
        width = guiGetTextWidth2(fontId, fast left$(text$, minChar-1)) + guiGetTextWidth2(fontId, mid$(text$, minChar))/2
        if width > pos
            dec minChar
        endif
    else
        if minChar > 0 then dec minChar
    endif
endfunction minChar